---
title: Group Project Deliverable 4
date: 10/9/2023
author: Rachel Farzan, Javeria Hanif, Feyza Sakin
format:
    html:
        theme: cosmo
        toc: true
        embed-resources: true

---

# ER Diagrams
### Chen Notation Diagram

```{dot}
graph ER {
    layout=neato;
    scale=2;
    node [shape=box]; playlist, album, song, user, artist
    node [shape=ellipse]; playlist_ID, playlist_name, user, description, album_ID, album_name, record_label, genre, song_ID, song_name, tempo, key, user_ID, user_name, password, account_type, plays, song_number, album_classification, playlist_description, album_duration, song_duration, release_date, birth_date, debut_date,playlist_duration, artist_name, artist_ID, follower_count, following_count
    node [shape=diamond,style=filled,color=lightgrey]; has, "has ",is, " has", " has ", "  has ", following
    
    playlist -- has [label="0...n",len=1.00]
    has -- song [label="1...n",len=1.00]

    playlist -- "has " [label="0...n",len=1.00]
    "has " -- user [label="1",len=1.00]

    artist -- is [label="0...1",len=1.00]
    is -- user [label="1",len=1.00]

    artist -- " has" [label="1",len=1.00]
    " has" -- album [label="1...n",len=1.00]

    album -- " has " [label="1",len=1.00]
    " has " -- song [label="1...n",len=1.00]

    artist -- "  has " [label="1...n",len=1.00]
    "  has " -- song [label="1...n",len=1.00]

    user -- following [label="0...n",len=1.00]
    following -- user [label="0...n",len=1.00]
    
    playlist -- playlist_ID
    playlist -- playlist_name
    playlist -- song_number
    playlist -- playlist_description
    playlist -- playlist_duration
    
    album -- album_ID
    album -- record_label
    album -- album_classification
    album -- genre
    album -- album_name
    album -- album_duration
    album -- release_date

    song -- song_ID
    song -- song_name
    song -- tempo
    song -- key
    song -- plays
    song -- song_duration

    user -- user_ID
    user -- user_name
    user -- account_type
    user -- password
    user -- follower_count
    user -- following_count

    artist -- artist_ID
    artist -- description
    artist -- birth_date
    artist -- debut_date
    artist -- artist_name

} 
```

### Crow's Foot Diagram
```{mermaid}
erDiagram
    PLAYLIST }o--o{ SONG : has
    ALBUM ||--|{ SONG : has
    ARTIST }|--|{ ALBUM : has
    USER ||--o{ PLAYLIST : has
    ARTIST |o--|| USER : is
    ARTIST }|--|{ SONG : has

    PLAYLIST{
        string ID PK
        string name
        string user_ID FK
        string description
        int duration
        int song_number
    }

    ALBUM{
        string ID PK
        string name
        string record_label
        string genre
        date release_date
        string classification
        int duration
        string artist_ID FK
    }

    SONG{
        string ID PK
        string name
        int tempo
        string key
        int plays
        int duration
        string artist_ID FK
        string album_ID FK
    } 

    USER {
        string ID PK
        string user_name
        string password
        string account_type
        int follower_count
        int following_count
    }

    ARTIST {
        string ID PK
        string artist_name
        date birth_date
        string description
        date debut_date
    }


```

### Design Notes

One thought that we had was to possibly have an album be a more specific type of playlist (a playlist that only an artist can make). However, we also wanted ot include features that only playlists could have (i.e. discriptions). It also seemed unnecessary to connect albums and playlists, so we ultimately decided not to.

We also had to consider which relationships to make many-to-many. Songs are often by multiple artist, so we made that relationship many-to-many. Though albums aren't as often by multiple artist, we thought it would be the most consistent to also make that relationship many-to-many. Though songs can also be on multiple albums, they often show up as separate songs on music apps like Spotify, so we decided to keep that relationship as one-to-many.

[Add other trade-offs]

# Relational Schemas

user (ID [PK], user_name [NOT_NULL, UNIQUE], password [NOT_NULL], account_type [(free, premium, artist)])

artist (ID [PK], name [NOT_NULL], birth_date [NOT_NULL], description, debut_date [NOT_NULL])

song (ID [PK], name [NOT_NULL], tempo, key, plays [NOT_NULL], duration [NOT_NULL], artist_ID [FK], album_ID [FK])

album (ID [PK], name [NOT_NULL], record_label [NOT_NULL], genre, release_date [NOT_NULL], classification [NOT_NULL], duration [NOT_NULL], artist_ID[FK])

playlist (ID [PK], name [NOT_NULL], description, duration [NOT_NULL], song_number [NOT_NULL], user_ID[FK])

artist_song (ID [PK], artist_ID[FK], song_ID[FK])

        FK(artist_ID) references artist.ID

        FK(song_ID) references song.ID

artist_album (ID [PK], artist_ID[FK], album_ID[FK])

        FK(artist_ID) references artist.ID

        FK(album_ID) references album.ID

playlist_song (ID [PK], playlist_ID[FK], song_ID[FK])

        FK(playlist_ID) references playlist.ID
    
        FK(song_ID) references song.ID


following (ID [PK], follower_ID[FK], following_ID[FK])

        FK(follower_ID) references user.ID

        FK(following_ID) references user.ID

# Functional Dependencies

user (ID, user_name, password, account_type)

        ID -> user_name, password, account_type

artist (ID, name, birth_date, description, debut_date)

        ID -> name, birth_date, description, debut_date

song (ID, name, tempo, key, plays, duration, artist_ID, album_ID)

        ID -> name, tempo, key, plays, duration, artist_ID, album_ID

album (ID, name, record_label, genre, release_date, classification, duration, artist_ID)

        ID -> name, record_label, genre, release_date, classification, duration, artist_ID

playlist (ID, name, description, duration, song_number, user_ID)

        ID -> name, description, duration, song_number, user_ID

artist_song (ID, artist_ID, song_ID)

        ID -> artist_ID, song_ID

artist_album (ID, artist_ID, album_ID)

        ID -> artist_ID, album_ID

playlist_song (ID, playlist_ID, song_ID)

        ID -> playlist_ID, song_ID

following (ID, follower_ID, following_ID)

        ID -> follower_ID, following_ID

#### Normalization Notes

Our relations are already in BCNF, as each relation consist of 1 functional dependency, where the candidate key determines everything else in the relation.